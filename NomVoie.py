# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NomVoie
                                 A QGIS plugin
 NomVoie
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-04-26
        git sha              : $Format:%H$
        copyright            : (C) 2022 by NomVoie
        email                : NomVoie@NomVoie.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from .resources import *

from qgis.core import QgsProject
from qgis.core import QgsVectorLayer
from qgis.core import QgsDataSourceUri
# Import the code for the DockWidget
from .NomVoie_dockwidget import NomVoieDockWidget
import os.path
import csv
from qgis.core import NULL
import psycopg2


class NomVoie:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'NomVoie_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NomVoie')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'NomVoie')
        self.toolbar.setObjectName(u'NomVoie')
        #initialisation de la commune
        self.commune     = str("")
        self.tble_voirie = str("")
        self.vlayer      = str("")
        self.table       = str("")
        self.uri         = QgsDataSourceUri()
        self.modif       = False
        self.typo        = str("")
        #print "** INITIALIZING NomVoie"
        #print "** INITIALIZING NomVoie"

        self.pluginIsActive = False
        self.dockwidget     = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallBytypologie
        return QCoreApplication.translate('NomVoie', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag  =True,
        add_to_menu   =True,
        add_to_toolbar=True,
        status_tip    =None,
        whats_this    =None,
        parent        =None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/NomVoie/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'DÃ©nomination de voie'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING NomVoie"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD NomVoie"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NomVoie'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar
    #--------------------------------------------------------------------------
    SCHEMA   ="public"
    DBNAME   ="bdpada"
    HOST     ="127.0.0.1"
    PORT     = "5432"
    USERNAME ='postgres'
    PASSWORD =''
    connstr  =""
    #--------------------------------------------------------------------------
    def log(self):   
        try:
            QgsProject.instance().removeMapLayer(self.table)
        except:
            pass
        try:
            QgsProject.instance().removeMapLayer(self.vlayer)
        except:
            pass 
        self.uri = QgsDataSourceUri()
        self.USERNAME    = str(self.dockwidget.op_name_lst_2.text())
        self.PASSWORD    = str(self.dockwidget.pass_line.text())
        self.HOST        = str(self.dockwidget.IP_name.text())
        self.PORT        = str(self.dockwidget.PORT_name.text())
        self.commune     = "" #str(self.dockwidget.op_name_lst_5.currentText())
        self.tble_voirie = str(self.dockwidget.voirie_pada.currentText())
   
        if self.USERNAME != "" and self.PASSWORD != "" and self.tble_voirie!="":
            self.connstr  = "dbname='" + self.DBNAME + "' host='" + self.HOST + "' port='"+self.PORT+ "' user='" + self.USERNAME + "' password='" + self.PASSWORD + "'"
            self.uri.setConnection(self.HOST, self.PORT, self.DBNAME, self.USERNAME, self.PASSWORD )
            self.uri.setDataSource('public', "toponymes",None,"typologie!='Routes Structurantes'")
            self.table = QgsVectorLayer(self.uri.uri(), "toponymes", "postgres")
            QgsProject.instance().addMapLayer(self.table)
            # if self.commune=='TOUS':
            #     self.uri.setDataSource('public', self.tble_voirie,"geom","atelier=1")
            # else:
            #     ip='"atelier"=1 and ("commune"='+"'"+self.commune+"' or "+'"commune"='+"'INTERCOMMUNAL')"
            #     self.dockwidget.label_18.setText(self.commune+' Rue Navigateur')
            #     self.uri.setDataSource('public', self.tble_voirie,"geom",ip)
            # vlayer = QgsVectorLayer(self.uri.uri(), self.tble_voirie, "postgres")
            # QgsProject.instance().addMapLayer(vlayer)


            #self.majManuel()
            #self.bilanCom() 
            self.ComboCom() 
            self.selectTypo()
            #self.dockwidget.commune.setCurrentText(self.commune)
            self.loadList()
            self.dockwidget.toolBox.setCurrentIndex(1)
            
        else:
            self.iface.messageBar().pushInfo("Info",": Nom d'utilisateur ou mot de passe ou table voirie vide ðŸ¤·â€â™€ï¸ðŸ˜’!!!")
            return
        
    def log_1(self):
        try:
            QgsProject.instance().removeMapLayer(self.table)
        except:
            pass
        try:
            QgsProject.instance().removeMapLayer(self.vlayer)
        except:
            pass
        self.commune  = str(self.dockwidget.commune.currentText()) #rÃ©cupÃ©ration de la valeur de la combo commune
        self.uri.setDataSource('public',  "toponymes",None,"typologie!='Routes Structurantes'")
        self.table    = QgsVectorLayer(self.uri.uri(), "toponymes", "postgres")
        QgsProject.instance().addMapLayer(self.table) #ouverture de la couche toponymes_test
        #-----------------------------------------------------------------------------------------------------------------------#
        #                   Si la commune est Ã©gale a 'TOUS' ouvrir la couche 'voirie_pada_test' sinon                               #
        #                   ouvrir uniquement la couche 'voirie_pada_test' avec la commune sÃ©lectionnÃ©e                              #
        #-----------------------------------------------------------------------------------------------------------------------#
        if self.commune=='TOUS':
            self.uri.setDataSource('public', self.tble_voirie,"geom","atelier=1")
        else:
            ip = '"atelier"=1 and ("commune"='+"'"+self.commune+"' or "+'"commune"='+"'INTERCOMMUNAL')"
            self.dockwidget.label_18.setText(self.commune+' Rue Navigateur')
            self.uri.setDataSource('public', self.tble_voirie,"geom",ip)
        self.vlayer = QgsVectorLayer(self.uri.uri(), self.tble_voirie, "postgres")
        QgsProject.instance().addMapLayer(self.vlayer)

        
        self.bilanCom()       
        self.selectTypo()
        self.loadList()
    
    
    def ComboCom(self):
        self.dockwidget.commune.clear()
        self.dockwidget.commune.addItem("TOUS")
        #self.dockwidget.comboBox.clear()
        #self.dockwidget.comboBox.addItem("TOUS")
        uniques     = []
        self.exists = False
        #cond        = "commune='"+str(self.commune)+"'"
        #self.iface.messageBar().pushInfo("Info",cond)
        lists = QgsProject.instance().mapLayersByName("toponymes")[0] #rÃ©cupÃ©ration de la table toponymes
        lista = sorted(lists.getFeatures(),key=lambda feature:feature["commune"])
        for i in lista: #pour chaque ligne de la table toponyme ajouter dans la liste de nom proposer
            #i["gid_ati"]==None and
            if i["commune"]!=None:
                self.exists = False
                for unique in uniques:
                    if str(i["commune"]) == str(unique["commune"]):
                        self.exists = True
                if self.exists == False:
                    self.dockwidget.commune.addItem(str(i["commune"]))
                    #self.dockwidget.comboBox.addItem(str(i["commune"]))
                    uniques.append(i)

    
    def selectTypo(self): #remplissage de la combo 'typologie' trier les typologies par commune
        self.dockwidget.typologie.clear()
        self.dockwidget.typologie.addItem("TOUS")
        uniques     = []
        self.exists = False
        cond        = "commune='"+str(self.commune)+"'"
        #self.iface.messageBar().pushInfo("Info",cond)
        lists = QgsProject.instance().mapLayersByName("toponymes")[0] #rÃ©cupÃ©ration de la table toponymes
        if self.commune=='INTERCOMMUNAL':
            lista=sorted(lists.getFeatures(),key=lambda feature:feature["id"])
        else:
            lista=sorted(lists.getFeatures(cond),key=lambda feature:feature["id"])
        for i in lista: #pour chaque ligne de la table toponyme ajouter dans la liste de nom proposer
            if i["gid_ati"]==None and i["nom_propose"]!=None:
                self.exists = False
                for unique in uniques:
                    if str(i["typologie"]) == str(unique["typologie"]):
                        self.exists=True
                if self.exists == False:
                    self.dockwidget.typologie.addItem(str(i["typologie"]))
                    uniques.append(i)
    #bilan de la commune en cours...
    def bilanCom(self):
        def bilanTotal(type_voie):
            if self.commune=="TOUS":
                cond  = "type_voie ilike '%{}%'".format(type_voie)
            else:
                cond  = "commune ilike '%"+self.commune+"%' and type_voie ilike '%{}%'".format(type_voie)
            lists = QgsProject.instance().mapLayersByName(self.tble_voirie)[0] #rÃ©cupÃ©ration de la table voirie
            lista = sorted(lists.getFeatures(cond),key=lambda feature:feature["id"])
            nbre  = 0
            for i in lista:
                nbre = nbre+1
            return nbre
        def bilanNommer(type_voie):
            if self.commune=="TOUS":
                cond  = "type_voie ilike '%{}%'and new_name is not null".format(type_voie)
            else:
                cond  = "commune ilike '%"+self.commune+"%' and type_voie ilike '%{}%'and new_name is not null".format(type_voie)
            lists = QgsProject.instance().mapLayersByName(self.tble_voirie)[0] #rÃ©cupÃ©ration de la table voirie
            lista = sorted(lists.getFeatures(cond),key=lambda feature:feature["id"])
            nbre  = 0
            for i in lista:
                nbre = nbre+1
            return nbre
        def bilanRest(type_voie):
            if self.commune=="TOUS":
                cond  = "type_voie ilike '%{}%' and new_name is null".format(type_voie)
            else:
                cond  = "commune ilike '%"+self.commune+"%' and type_voie ilike '%{}%' and new_name is null".format(type_voie)
            lists = QgsProject.instance().mapLayersByName(self.tble_voirie)[0] #rÃ©cupÃ©ration de la table voirie
            lista = sorted(lists.getFeatures(cond),key=lambda feature:feature["id"])
            nbre  = 0
            for i in lista:
                nbre = nbre+1
            return nbre
        self.dockwidget.label_bilan.setText("Bilan de la commune: "+self.commune+" - "+str(bilanTotal("Rue")+bilanTotal("Place")+bilanTotal("Avenue")+bilanTotal("N/C")+bilanTotal("Route")+bilanTotal("Alle")+bilanTotal("Boulevard")+bilanTotal("Avenue"))+" voies")
        self.dockwidget.bilan_commune.setText(str(bilanTotal("Rue"))+" rue "+str(bilanTotal("Place"))+" Place "+str(bilanTotal("Avenue"))+" Avenue "+str(bilanTotal("N/C"))+" N/C "+str(bilanTotal("Route"))+" Route "+str(bilanTotal("Allee"))+" Allee "+str(bilanTotal("Boulevard"))+" Boulevard ")
        self.dockwidget.label_voienomer.setText("nombre de voie nommer: "+str(bilanNommer("Rue")+bilanNommer("Place")+bilanNommer("Avenue")+bilanNommer("N/C")+bilanNommer("Route")+bilanNommer("Alle")+bilanNommer("Boulevard")+bilanNommer("Avenue"))+" voies")
        self.dockwidget.bilan_deno.setText(str(bilanNommer("Rue"))+" rue "+str(bilanNommer("Place"))+" Place "+str(bilanNommer("Avenue"))+" Avenue "+str(bilanNommer("N/C"))+" N/C "+str(bilanNommer("Route"))+" Route "+str(bilanNommer("Allee"))+" Allee "+str(bilanNommer("Boulevard"))+" Boulevard ")
        self.dockwidget.label_voierestant.setText("nombre de voie restant: "+str(bilanRest("Rue")+bilanRest("Place")+bilanRest("Avenue")+bilanRest("N/C")+bilanRest("Route")+bilanRest("Alle")+bilanRest("Boulevard")+bilanRest("Avenue"))+" voies")
        self.dockwidget.bilan_rest.setText(str(bilanRest("Rue"))+" rue "+str(bilanRest("Place"))+" Place "+str(bilanRest("Avenue"))+" Avenue "+str(bilanRest("N/C"))+" N/C "+str(bilanRest("Route"))+" Route "+str(bilanRest("Allee"))+" Allee "+str(bilanRest("Boulevard"))+" Boulevard ")
        
        
    #trier les noms proposer par typologie
    def TrieTypo(self):
        #self.dockwidget.codl.clear()
        comboTrie = self.dockwidget.typologie.currentText()
        self.typo = self.dockwidget.typologie.currentText()
        if comboTrie =="TOUS":
            #self.iface.messageBar().pushInfo("Info","exsecution ")
            self.selectNom()
        else:
            tip = ''
            c   = False
            self.dockwidget.label_8.setText('')
            try:
                layer = QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
            except:
                self.iface.messageBar().pushInfo("Info",": Aucune couche n'est sÃ©lctionnÃ©e!!!")
                return
            selected_features = layer.selectedFeatures()
            print(len(selected_features))
            print(c)
            if len(selected_features)!=0:
                print('da')
                for j in selected_features:
                    tip          = j['type_voie']
                    com          = j["commune" ]
                    self.commune = j["commune" ]
                    self.dockwidget.label_8.setText(tip)
                    self.id_voie = j["id_voie"]
                print(tip)
                
                inter ="commune='"+str(com)+"' and typologie='"+str(comboTrie)+"'"
                print(inter)
                #self.iface.messageBar().pushInfo("Info",inter)
                lists = QgsProject.instance().mapLayersByName("toponymes")[0]
                if com=='INTERCOMMUNAL':
                    lista=sorted(lists.getFeatures("typologie='"+str(comboTrie)+"'"),key=lambda feature:feature["nom_propose"])
                else:
                    lista=sorted(lists.getFeatures(inter),key=lambda feature:feature["nom_propose"])
                self.dockwidget.codl.clear()
                print(len(lista))
                for i in lista:
                    #self.iface.messageBar().pushInfo("Info",str(i["nom_propose"]))
                    self.gid= i["id"]
                    #print(self.gid)
                    c       = True
                    self.pro= True
                    if i["gid_ati"]==None and i["nom_propose"]!=NULL:
                        if com=='INTERCOMMUNAL' or com=='DA':
                            self.dockwidget.codl.addItem(str(i["nom_propose"])+'==>'+str(i["commune"]))
                        else:
                            self.dockwidget.codl.addItem(str(i["nom_propose"]))
                if c==False and self.pro==False:

                    for i in lista:
                        self.dockwidget.codl.addItem(str(i["nom_propose"]))


    
    def select(self):
        #self.dockwidget.typologie.setCurrentIndex (0)
        self.selectNom()
    
    def majManuel(self):
        self.connstr="dbname='" + self.DBNAME + "' host='" + self.HOST + "'port='"+self.PORT+"' user='" + self.USERNAME + "' password='" + self.PASSWORD + "'"
        conn = psycopg2.connect(self.connstr)
        cur  = conn.cursor()
        sql  = "UPDATE public.toponymes t SET observation='AttribuÃ©', gid_ati=v.id_voie FROM public."+self.tble_voirie+" v WHERE upper(trim(t.nom_propose)) = upper(trim(v.new_name)) and t.gid_ati is null and t.gid_ati is null;"
        sql1 = "UPDATE public.toponymes SET observation='AttribuÃ©' WHERE observation is null and gid_ati is not null;"
        sql2 = "UPDATE public.toponymes SET observation=Null WHERE observation is not null and gid_ati is  null;"
        cur.execute(sql)
        cur.execute(sql1)
        cur.execute(sql2)
        conn.commit()
        cur.close()
        conn.close()
        self.iface.messageBar().pushInfo("Info",": base de donnÃ©e mise Ã  jour avec succÃ¨s!!!")
                    
        
    def loadList(self):
        self.dockwidget.codl.clear()
        lists = QgsProject.instance().mapLayersByName("toponymes")[0]
        lista = sorted(lists.getFeatures(),key=lambda feature:feature["nom_propose"])
        for i in lista:
            if self.commune=="TOUS":
                if i["gid_ati"]==None and i["nom_propose"]!=NULL:
                    self.dockwidget.codl.addItem(str(i["nom_propose"]))
            else:
                if i["gid_ati"]==None and i["nom_propose"]!=NULL and i["commune"]==self.commune:
                    self.dockwidget.codl.addItem(str(i["nom_propose"]))

    currentVoieIndex=-1
    gid    =0
    comm   =''
    id_voie=0
    pro    =False

    def selectNom(self):
        tip     =''
        c       =False
        self.pro=False
        self.dockwidget.label_8.setText('')
        try:
            layer=QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
        except:
            self.iface.messageBar().pushInfo("Info",": Aucune couche n'est sÃ©lctionnÃ©e!!!")
            return
        selected_features = layer.selectedFeatures()
        if len(selected_features)!=1:
                self.iface.messageBar().pushInfo("Info",": Plusieurs routes sont sÃ©lectionnÃ©es ou aucune voie n'est sÃ©lectionnÃ©eâ›”. SÃ©lectionnez une seul SVPðŸ™!!!")
                self.dockwidget.codl.clear()
                return
        if len(selected_features)!=0:
            for j in selected_features:
                if j['type_voie'] =='Boulevard':
                    tip='Boulevard' 
                else:
                    if j['type_voie']=='Avenue':
                        tip='Avenue'
                    else:
                        tip='Rue'
                    
                com=j["commune" ]
                self.commune=j["commune" ]
                self.dockwidget.label_8.setText(str(tip))
                self.id_voie=j["id_voie"]
            inter="commune='"+str(com)+"'"
            lists = QgsProject.instance().mapLayersByName("toponymes")[0]
            if self.commune=='TOUS':
                lista=sorted(lists.getFeatures(),key=lambda feature:feature["nom_propose"])
            else:
                lista=sorted(lists.getFeatures(inter),key=lambda feature:feature["nom_propose"])
            self.dockwidget.codl.clear()
            for i in lista:
                self.gid=i["id"]
                c       =True
                self.pro=True
                
                if self.commune=='TOUS':
                    if i["gid_ati"]==None and i["nom_propose"]!=NULL:
                        self.dockwidget.codl.addItem(str(i["nom_propose"]))
                else:
                    if i["gid_ati"]==None and i["nom_propose"]!=NULL and i["commune"]==self.commune:
                        self.dockwidget.codl.addItem(str(i["nom_propose"]))
                 
            if c==False:
               for i in lista:
                   self.dockwidget.codl.addItem(str(i["nom_propose"]))
                   self.dockwidget.label_8.setText(tip+': repertoire Ã©pusÃ©')
                   self.pro=False
        else:
            self.dockwidget.codl.clear()
            self.loadList()
        
    
    def Next(self,feature):
        
        layer=QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
        self.blocks = sorted(layer.getFeatures(),key=lambda feature:feature["id_voie"])
        max=len(self.blocks)
        self.currentVoieIndex=self.currentVoieIndex+1
        if self.currentVoieIndex>max-1:   
            self.currentVoieIndex=0
        feature1=self.blocks[self.currentVoieIndex]
        while feature1["new_name"] != NULL:
            print('next')
            print(feature1["new_name"])
            self.currentVoieIndex=self.currentVoieIndex+1
            print(self.currentVoieIndex)
            print(max)
            if self.currentVoieIndex>max-1:   
                self.currentVoieIndex=0
            feature1=self.blocks[self.currentVoieIndex]
            #print(self.currentVoieIndex)
        if self.currentVoieIndex>max-1:   
            self.currentVoieIndex=0
            
        feature=self.blocks[self.currentVoieIndex]
        #if  feature["work_state"] != 'C0':
        self.ZoomToFeature(feature)

    def Prev(self,feature):
        layer=QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
        self.blocks = sorted(layer.getFeatures(),key=lambda feature:feature["id"])
        max=len(self.blocks)
        self.currentVoieIndex=self.currentVoieIndex-1
        if self.currentVoieIndex<0:   
            self.currentVoieIndex=max-1  
        feature1=self.blocks[self.currentVoieIndex]
        while feature1["new_name"] != NULL:
            self.currentVoieIndex=self.currentVoieIndex-1
            feature1=self.blocks[self.currentVoieIndex]
            #print(self.currentVoieIndex)
        if self.currentVoieIndex<0:   
            self.currentVoieIndex=max-1
        
        feature=self.blocks[self.currentVoieIndex]
        self.ZoomToFeature(feature)

    def ZoomToFeature(self,feature):
        box = feature.geometry().buffer(20,2).boundingBox()
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        layer = self.iface.activeLayer()
        layer.selectByExpression(" \"id_voie\" = '{}' ".format(feature['id_voie']))
        

    def write(self):
        if len(self.dockwidget.codl.selectedItems()) != 0:
            z=str(self.dockwidget.codl.currentItem().text())
            
        else:
            self.iface.messageBar().pushInfo("Info",":SÃ©lectionnez un nom SVP ðŸ™!!!")
            return
        if self.commune!='INTERCOMMUNAL':
            ip="nom_propose="+'"'+str(z)+'"'+" and commune='"+self.commune+"'"
            print(ip)
        else:
            # print(str(z).split('==>'))
            # p=str(z).split('==>')
            ip="nom_propose="+'"'+str(z)+'"'+" and commune='"+self.commune+"'"
            print(ip)
        nom=str(z)
        nom=nom.replace("'","''")
        layer=QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
        selected_features = layer.selectedFeatures()

        for feature in selected_features:
            if len(selected_features)!=1:
                self.iface.messageBar().pushInfo("Info",": Plusieurs voies sont sÃ©lectionnÃ©esâ›”â›”â›”. SÃ©lectionnez une seul SVPðŸ™!!!")
                return
            else:
                #self.iface.messageBar().pushInfo("Info",str(self.modif))
                
                if feature['new_name']!=NULL and self.modif==False:
                    self.iface.messageBar().pushInfo("Info",": âš âš âš  Cette voie a dÃ©ja Ã©tÃ© nommer. Appuyer sur le boutton 'Changement de nom' pour la modifier !!!")
                    return
                else:
                    if feature['new_name']==NULL and self.modif==True:
                        self.iface.messageBar().pushInfo("Info",": âš âš âš  Cette voie n'a pas de nom. donc elle ne peut pas Ãªtre modifier !!!")
                        self.modif=False
                        return
                    else:
                        com                 =feature["commune"]
                        layer.startEditing()
                        feature['new_name'] =z
                        self.id_voie        =feature['id_voie']
                        layer.updateFeature(feature)
                        layer.commitChanges()
                        self.modif= False
                        
        lists = QgsProject.instance().mapLayersByName("toponymes")[0]
        lista = sorted(lists.getFeatures(ip),key=lambda feature:feature["id"])
        lists.startEditing()
        print(lista)
        for i in lista:
            i["observation"]='AttribuÃ©'
            i["gid_ati"]=self.id_voie
            lists.updateFeature(i)
            print(i["gid_ati"])
            
        lists.commitChanges()
        self.connstr="dbname='" + self.DBNAME + "' host='" + self.HOST + "'port='"+self.PORT+"' user='" + self.USERNAME + "' password='" + self.PASSWORD + "'"
        conn = psycopg2.connect(self.connstr)
        cur = conn.cursor()
        sql="Update public.toponymes set observation='AttribuÃ©' where nom_propose='"+nom+"' and commune='"+com+"';"
        sql1='Update public.toponymes set gid_ati='+str(self.id_voie) +" where nom_propose='"+nom+"' and commune='"+com+"';"
        print(sql)
        cur.execute(sql)
        cur.execute(sql1)
        conn.commit()
        cur.close()
        conn.close()
        
        self.bilanCom() 
        self.ComboCom()
        #self.selectTypo()
        self.TrieTypo()
        self.dockwidget.typologie.setCurrentText(self.typo) 
        self.iface.messageBar().pushInfo("Info",": Voie nommer avec succÃ¨s âœ…")
                
        
    def changeN(self):
        if len(self.dockwidget.codl.selectedItems()) != 0:
            z=str(self.dockwidget.codl.currentItem().text())
            
        else:
            self.iface.messageBar().pushInfo("Info",":SÃ©lectionnez un nom SVPðŸ™ !!!")
            return
        layer=QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
        selected_features = layer.selectedFeatures()
        for feature in selected_features:
            if len(selected_features)!=1:
                self.iface.messageBar().pushInfo("Info",": Plusieurs voies sont sÃ©lectionnÃ©esâ›”âŒ. SÃ©lectionnez une seul SVP ðŸ™! !!")
                return
            else:
                nom=feature['new_name']
                print(nom)
                com=feature["commune"]
        lists = QgsProject.instance().mapLayersByName("toponymes")[0]
        lista=sorted(lists.getFeatures(),key=lambda feature:feature["id"])
        for i in lista:
            if i['nom_propose']==nom and i["commune"]==com:
                print(nom)
                lists.startEditing()
                print(i["id"])
                i["gid_ati"]=NULL
                i.setAttribute('gid_ati', NULL)
                i["gid_ati"]=NULL
                i.setAttribute('gid_ati', NULL)
                lists.updateFeature(i)
                self.connstr="dbname='" + self.DBNAME + "' host='" + self.HOST + "'port='"+self.PORT+"' user='" + self.USERNAME + "' password='" + self.PASSWORD + "'"
                conn = psycopg2.connect(self.connstr)
                cur  = conn.cursor()
                nom  = nom.replace("'","''")
                sql  = "Update public.toponymes set gid_ati=NULL where nom_propose='"+nom+"' and commune='"+com+"';"
                sql1 = "Update public.toponymes set gid_ati=NULL where nom_propose='"+nom+"' and commune='"+com+"';"
                print(sql)
                print(sql)
                cur.execute(sql)
                cur.execute(sql1)
                conn.commit()
                cur.close()
                conn.close()

            #print(i["gid_ati"])
        lists.commitChanges()

        self.modif=True
        self.write()
        if self.modif==True:
            self.iface.messageBar().pushInfo("Info",":Nom de voie modifier avec succÃ¨s âœ…")
           
    def retirer(self):
        layer=QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
        selected_features = layer.selectedFeatures()
        for feature in selected_features:
            if len(selected_features)!=1:
                self.iface.messageBar().pushInfo("Info",": Plusieurs voies sont sÃ©lectionnÃ©esâ›”âŒ. SÃ©lectionnez une seul SVP ðŸ™! !!")
                return
            else:
                nom=feature['new_name']
                com=feature["commune"]
            if nom==None:
                self.iface.messageBar().pushInfo("Info",": Cette voie n'a pas de nom!!!âš ") 
                return 
            else: 
                self.connstr="dbname='" + self.DBNAME + "' host='" + self.HOST + "'port='"+self.PORT+"' user='" + self.USERNAME + "' password='" + self.PASSWORD + "'"
                conn = psycopg2.connect(self.connstr)
                cur  = conn.cursor()
                nom  = nom.replace("'","''")
                sql  = "Update public.toponymes set observation=NULL, gid_ati=NULL where nom_propose='"+nom+"' and commune='"+com+"';"
                sql1 = "Update public."+self.tble_voirie+" set new_name=NULL  where new_name='"+nom+"' and commune='"+com+"';"
                cur.execute(sql)
                cur.execute(sql1)
                conn.commit()
                cur.close()
                conn.close()
                self.iface.messageBar().pushInfo("Info",":âœ… Nom retirer avec succÃ¨s !!!")
        self.bilanCom()
        #self.ComboCom()
        self.TrieTypo()  
        self.selectTypo()
        self.dockwidget.typologie.setCurrentText(self.typo) 
        
    
    def descr(self):
        self.dockwidget.Description_2.clear()
        if len(self.dockwidget.codl.selectedItems())==0:
           self.iface.messageBar().pushInfo("Info",": Aucun nom n'est sÃ©lectionnÃ©â›”â›”â›”!!!") 
           return
        lists = QgsProject.instance().mapLayersByName("toponymes")[0]
        z     = str(self.dockwidget.codl.currentItem().text())
        z     = z.replace("'","''")
        layer=QgsProject.instance().mapLayersByName(self.tble_voirie)[0]
        selected_features = layer.selectedFeatures()
        if len(selected_features)!=1:
                self.iface.messageBar().pushInfo("Info",": Aucune voie n'est sÃ©lectionnÃ©eâ›”â›”â›”.!!!")
                #self.dockwidget.codl.clear()
                return
        if self.commune!='INTERCOMMUNAL':
            ip="nom_propose ilike "+"'"+str(z)+"'"+" and commune ilike '"+self.commune+"'"
            print(ip)
           
        else:
            print(str(z).split('==>'))
            p=str(self.commune).split('==>')
            ip="nom_propose ilike "+"'"+str(z)+"'"+" and commune ilike '"+str(p[1])+"'"
            print(ip)
        lista=sorted(lists.getFeatures(ip),key=lambda feature:feature["id"])
        for i in lista:
            print(i["id"])
            self.dockwidget.Description_2.insertPlainText(str(i["description"]))
        self.dockwidget.toolBox.setCurrentIndex(2)

    def retourn(self):
        self.dockwidget.toolBox.setCurrentIndex(1)


    #--------------------------------------------------------------------------
    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING NomVoie"
            
            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = NomVoieDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            
            canvas = self.iface.mapCanvas()
            canvas.selectionChanged.connect(self.select)
            self.dockwidget.Load.clicked.connect(self.write)
            self.dockwidget.decr.clicked.connect(self.descr)
            self.dockwidget.back.clicked.connect(self.retourn)
            self.dockwidget.typologie.activated.connect(self.TrieTypo)
            self.dockwidget.prev.clicked.connect(self.Prev)
            self.dockwidget.next.clicked.connect(self.Next)
            self.dockwidget.BTN_START.clicked.connect(self.log)
            self.dockwidget.BTN_VALIDER.clicked.connect(self.log_1)
            self.dockwidget.Load_2.clicked.connect(self.changeN)
            self.dockwidget.majdata.clicked.connect(self.majManuel)
            self.dockwidget.retirer.clicked.connect(self.retirer)